<!DOCTYPE html>
<html>
    <head>
        <title>
            Implementing a WebSocket Server in C
        </title>
        <link href="../../index.css" rel="stylesheet" />
        <link href="../../article.css" rel="stylesheet" />
    </head>
    <body>
        <div class="navbar">
            <a class="name navbutton" href="/writings">
                Luke's Writings
            </a>
            <div class="navbuttons">
                <a href="/writings/archive" class="navbutton">
                    Archive
                </a>
                <a href="/writings/tags" class="navbutton">
                    Tags
                </a>
            </div>
        </div>
        <div class="article">
            <h1 class="title">
                Implementing a WebSocket Server in C
            </h1>
            <h3 class="byline">
                <span class="author">
                    Luke DiGiovanna
                </span>
                -
                <span class="date">
                    10/8/2024
                </span>
            </h3>
            <hr />
            <div class="content">
                <p>The WebSocket standard is useful for persistent two-way communication in web-based environments. This is what enables real time applications in browsers such as chat applications and multiplayer games.</p>
<p>WebSockets are an upgraded HTTP connection that is built on TCP. </p>
<p>For more information on the standard, refer to the <a href="https://datatracker.ietf.org/doc/rfc6455/?include_text=1">RFC 6455</a>.</p>
<p>This article will walk through the development of the simplest implementation of a WebSocket server in C using only Linux system calls (no libraries!)</p>
<h2>TCP</h2>
<p>To be able to establish a WebSocket connection, we need to be able to handle HTTP requests, which is just a protocol built on top of TCP. So really the first thing we need to do is set up a server to receive TCP connections.</p>
<h3>Connecting a server</h3>
<p>We open a socket to receive connections with the <code>socket(2)</code> system call as follows. (Note that I omitted error checking after syscalls here to make the important functionality clear, but it is good practice to always check for return errors when making syscalls).</p>
<pre><code class="language-c">// Set up a socket server
int server_socket_fd;
struct sockaddr_in server_address;

// Create socket file descriptor
server_socket_fd = socket(AF_INET, SOCK_STREAM, 0);

server_address.sin_family = AF_INET;
server_address.sin_port = htons(PORT);
server_address.sin_addr.s_addr = htonl(INADDR_ANY);

// Bind the socket file descriptor to the address
bind(server_socket_fd, &amp;server_address, sizeof(struct sockaddr_in));
</code></pre>
<h3>Receiving clients</h3>
<p>After configuring the server socket, we tell it to wait for a client, which opens
a file descriptor that we can read requests from.</p>
<pre><code class="language-c">struct sockaddr client_address;
socklen_t len;
int client_fd = accept(server_socket_fd, &amp;client_address, &amp;len);
</code></pre>
<h2>HTTP</h2>
<p>When we first get a connection from a client, we expect an HTTP request to 
establish the WebSocket handshake. This section requires an implementation of
HTTP. I wrote a very basic HTTP server that specifically handles the case of
setting up a WebSocket, but not much else (i.e. no sending files, handling
authentication, cookies, JSON, etc.). </p>
<blockquote>
<p>An alternative to writing your own HTTP implementation is to use a reverse 
proxy where you have another server setup to handle HTTP requests and sends 
that client to your WebSocket server.</p>
</blockquote>
<p>In any case, I will not walk through my HTTP implementation, but it simply
involves parsing an HTTP request.</p>
<h3>The WebSocket Handshake Request</h3>
<p>The handshake must be done before data can be sent back and forth. The purpose of this handshake is for the server to prove to the client that it supports the WebSocket protocol. This is done with an HTTP request that usually looks something like:</p>
<pre><code>GET / HTTP/1.1
Host: https://my-site.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGVzdF9rZXk=
Sec-WebSocket-Version: 13
</code></pre>
<p>The most important header here is <code>Sec-WebSocket-Key</code>. The client sends this
for the server to prove to the client that it supports the WebSocket protocol.
This process works as follows:</p>
<ol>
<li>The server appends the GUID <code>"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</code> to the provided <code>Sec-WebSocket-Key</code>. This GUID was chosen as the standard since it is "unlikely to be used by network endpoints that do not understand the WebSocket protocol"</li>
<li>Then hashes this string using SHA-1 (note the weak cryptographic security of SHA-1 is not a concern as this is primarily done just as part of the protocol, not to protect sensitive data)</li>
<li>Then base64 encodes this hash.</li>
</ol>
<p>Then the server sends an HTTP response back to the client with the <code>101 Switching Protocols</code> status code and the result of the above process in the <code>Sec-WebSocket-Accept</code> header.</p>
<p>This response may look something like:</p>
<pre><code>HTTP/1.1 101 Switching Protocols
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOr=
Connection: Upgrade
Upgrade: websocket
</code></pre>
<p>Upon receipt, the client knows that it can start sending and receiving WebSocket frames from this server.</p>
<h2>WebSocket Duplex Communication</h2>
<p>The WebSocket protocol uses the concept of frames to send messages </p>
<h2>Resources Used</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview">Mozilla's HTTP Overview</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">Mozila's Writing WebSocket servers</a></p>
            </div>
        </div>
    </body>
</html>